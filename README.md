# 线程池项目文档

## 概述

本项目是一个基于C++简单的线程池实现，旨在提供一种方便的方式来管理并发执行的任务。线程池是一种常见的并发编程模式，通过重用线程来降低创建和销毁线程的开销，从而提高程序的性能和效率。


## 功能特性

- 管理线程生命周期：自动创建和销毁线程，根据任务的数量动态调整线程池大小。（我还没实现）
- 提供任务队列：支持提交任务到线程池执行，并按顺序执行。
- 可配置的参数：允许设置线程池大小、任务队列大小、拒绝策略等参数。（我还没实现完）


## 项目结构
### ThreadPool 类
#### 构造函数 (ThreadPool::ThreadPool())： 初始化线程池，创建固定数量（InitThreadNum，未在代码段中定义，假设为某个常量）的工作线程。每个工作线程都会执行execute_tasks成员函数，这个函数负责从任务队列中取出任务并执行。

#### 析构函数 (ThreadPool::~ThreadPool())： 在销毁线程池时，首先设置一个标志（stop）来通知所有工作线程停止执行。然后，它会唤醒所有可能正在等待条件变量的线程，并等待所有工作线程完成当前任务并退出。

#### 添加任务 (void ThreadPool::add_task(const std::function<void()>& task))： 允许外部添加任务到线程池的任务队列中。每个任务是一个不接受参数并返回void的函数（std::function<void()>类型）。添加任务后，使用条件变量通知一个正在等待的工作线程。

#### 执行任务 (void ThreadPool::execute_tasks())： 工作线程执行的函数。它不断地从任务队列中取出任务并执行，直到线程池被销毁（即stop被设置为true且任务队列为空）。

#### 显示线程ID (void ThreadPool::show_threads())： 打印出所有工作线程的ID，用于调试目的。

### 主函数 (int main())：
#### 创建一个ThreadPool对象。
#### 使用ThreadPool对象的show_threads方法打印出所有工作线程的ID。
#### 循环10次，交替添加两种类型的任务到线程池：一种直接打印信息，另一种先等待200毫秒再打印信息。
#### 在所有任务添加完毕后，主线程等待5秒，以确保所有工作线程有足够的时间完成任务，然后程序退出。
#### 这个简单的线程池实现演示了如何使用C++11中引入的线程支持库来创建和管理线程，以及如何使用互斥锁（std::mutex）、条件变量（std::condition_variable）和功能对象（std::function）来同步线程间的操作和管理任务队列。

## 执行结果说明
在执行过程中，由于使用了 `std::cout` 进行输出，可能会导致输出结果混乱的情况。这种现象在多线程环境下是比较常见的，并且是由于 `std::cout` 的特性所致。如果想要避免这种情况，可以将 `task()` 放入上方的代码块执行原子操作。或者使用线程安全的输出，如果你确实需要实时输出，可以考虑使用线程安全的输出库，比如 `spdlog` 等，这些库能够更好地处理多线程环境下的输出问题。
